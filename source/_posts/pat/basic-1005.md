title: PAT-Basic-1005 继续(3n+1)猜想
date: 2015-11-15 08:36:04
tags: [PAT,PAT Basic]
categories: [算法]
toc: false
---
卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。

当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的<!--more-->时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。

现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。

输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(<100)，第2行给出K个互不相同的待验证的正整数n(1<n<=100)的值，数字间用空格隔开。

输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。

输入样例：
6
3 5 6 7 8 11
输出样例：
7 6
## 解题思路
这题的核心思路和 1001. 害死人不偿命的(3n+1)猜想 的没有什么不同，就是在计算的时候多了一个打表操作，我的思路是这样的：对每个输入数字进行打表，开始先判断自己是否已经被 Check 到，如果没有就开始打表，这个打表过程是将遇到的步骤数都置为 1 ，这个过程并没有把自己本身的数置 1 ，这个任务交给别人去做，最后对输入的数据排序，再从最大的开始 Check 被 Mark 的数据表 ， 如果数据为 0 说明这个数没有被别的数 Cover 过，这个数就是“关键数字”代码如下：
```c
#include <stdio.h>
#include <stdlib.h>
#define tMax 5000
/* run this program using the console pauser or add your own getch, system("pause") or input loop */
int cmp(const void *a , const void *b ){ return -(*(int *)a - *(int *)b); }
int main(int argc, char *argv[]) {
	int Input[101];
	//测试过100以内最大的过程能达到4616，也可以通过判断减小数组大小这里是以空间换时间
	int Mark[tMax];  
	int k,i,n,flag;
	flag=1; //控制输出格式，还没想到更好的办法 
	for( i = 0 ; i < tMax ; i++ )
		Mark[i] = 0 ; 
	Mark[1] = 1 ;
	scanf("%d",&k);
	//代码核心部分，打表 
	for( i =0 ; i < k ; i++){
		scanf("%d",&Input[i]);
	} 
	//开始对输入的数据进行卡拉兹(Callatz)猜想打表 
	for( i = 0 ; i < k ; i++ ){
		n = Input[i];
		if( 1 != Mark[n] ){
			while( n != 1 ){
			n = n % 2 ? ( 3*n+1 ) / 2 : n / 2; 
			//进行打表后除了自己本身其它的步骤数都置 1 
			Mark[n] = 1;
			}
		}
	}
	//将输入数据进行降序快排，这里能否不用排序直接从Mark表由后往前开始读数据？暂时没想到方法	
	qsort(Input,k,sizeof(Input[1]),cmp);
	//格式输出部分 
	for( i=0 ; i<k ; i++ ){
			if( (0 == Mark[Input[i]]) && flag ){
				printf("%d",Input[i]);
				//应该有更好的格式控制输出方法，暂时没有想到 
				flag = 0;   
				continue;
			}
			if( 0 == Mark[Input[i]] ){
				printf(" %d",Input[i]);
			}
				
	} 
	return 0;
}
```
